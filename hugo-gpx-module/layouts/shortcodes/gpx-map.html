{{- /* --- 1. LANGUAGE SETTINGS --- */ -}}
{{- $lang := .Page.Lang | default "de" -}}
{{- $txtSummary := cond (eq $lang "de") "Zusammenfassung" "Summary" -}}
{{- $txtRoutes := cond (eq $lang "de") "Routen-Auswahl" "Route Selection" -}}
{{- $txtDist := cond (eq $lang "de") "Distanz" "Distance" -}}
{{- $txtEle := cond (eq $lang "de") "H√∂henmeter" "Elevation" -}}
{{- $txtTime := cond (eq $lang "de") "Gesamtzeit" "Total Time" -}}
{{- $txtRouteCount := cond (eq $lang "de") "Routen" "Routes" -}}
{{- $txtAll := cond (eq $lang "de") "Alle" "All" -}}
{{- $txtNone := cond (eq $lang "de") "Keine" "None" -}}
{{- $txtFocus := cond (eq $lang "de") "Fokus" "Focus" -}}
{{- $txtLoading := cond (eq $lang "de") "Karte wird geladen..." "Loading map..." -}}
{{- $txtError := cond (eq $lang "de") "Fehler" "Error" -}}
{{- $txtErrorMsg := cond (eq $lang "de") "Mindestens eine GPX-Datei erforderlich." "At least one GPX file is required." -}}

{{- /* --- 2. CONFIGURATION & DEFAULTS --- */ -}}
{{- $showStats := .Get "show-stats" | default "true" -}}
{{- $theme := .Get "theme" | default "light" -}}
{{- $width := .Get "width" | default "100%" -}}
{{- $height := .Get "height" | default "600px" -}}
{{- $routeMinWidth := .Get "route-min-width" | default "400px" -}}
{{- $statMinWidth := .Get "stat-min-width" | default "110px" -}}
{{- $id := printf "gpx-map-%d" .Ordinal -}}

{{- /* Marker Configuration */ -}}
{{- $showMarkers := .Get "markers" | default "true" -}}
{{- $markerStartColor := .Get "marker-start-color" | default "#2ecc71" -}}
{{- $markerEndColor := .Get "marker-end-color" | default "#e74c3c" -}}

{{- /* --- 3. GPX FILE PARSING --- */ -}}
{{- $gpxFiles := slice -}}
{{- if .IsNamedParams -}}
  {{- /* Handle named params: file="A.gpx", file2="B.gpx" */ -}}
  {{- if .Get "file" -}}{{- $gpxFiles = $gpxFiles | append (.Get "file") -}}{{- end -}}
  {{- range $i := seq 2 20 -}}
    {{- $key := printf "file%d" $i -}}
    {{- if $.Get $key -}}{{- $gpxFiles = $gpxFiles | append ($.Get $key) -}}{{- end -}}
  {{- end -}}
{{- else -}}
  {{- /* Handle positional params: "A.gpx", "B.gpx" */ -}}
  {{- range .Params -}}{{- $gpxFiles = $gpxFiles | append . -}}{{- end -}}
{{- end -}}

{{- if eq (len $gpxFiles) 0 -}}
  <div class="gpx-error" style="background: #fee; border: 1px solid #fcc; padding: 1rem; border-radius: 4px; color: #c00;">
    <strong>{{ $txtError }}:</strong> {{ $txtErrorMsg }}
  </div>
{{- else -}}

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  
  <style>
    /* Grid Layouts */
    #{{ $id }}-routes { display: grid; grid-template-columns: repeat(auto-fit, minmax({{ $routeMinWidth }}, 1fr)); gap: 0.5rem; }
    .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax({{ $statMinWidth }}, 1fr)); gap: 0.5rem; }

    /* Map & Z-Index Fixes */
    .gpx-map-container, .gpx-map-container .leaflet-container { z-index: 0 !important; position: relative !important; }
    header, nav, .navbar, .menu, .modal { z-index: 99999 !important; }
    .gpx-route-selector, .gpx-stats, .leaflet-control-layers { position: relative; z-index: 10 !important; }
    
    /* Leaflet Reset */
    #{{ $id }} .leaflet-pane, #{{ $id }} .leaflet-tile, #{{ $id }} .leaflet-marker-icon {
        max-width: none !important; max-height: none !important; margin: 0 !important; padding: 0 !important;
        box-shadow: none !important; border: none !important; 
    }
    #{{ $id }} .leaflet-zoom-animated { transition: transform 0.25s cubic-bezier(0,0,0.25,1) !important; }
    #{{ $id }} .leaflet-fade-anim .leaflet-tile { transition: opacity 0.2s linear !important; }
    
    /* General Styling */
    .gpx-map-container { text-align: left !important; font-family: system-ui, -apple-system, sans-serif; }
    .route-details { font-size: 0.8rem; color: #666; margin-top: 2px; display: flex; flex-wrap: wrap; gap: 8px; }
    .route-stat-pill { display: inline-flex; align-items: center; gap: 3px; white-space: nowrap; }
    .stat-elevation-detail { display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 0.9rem; line-height: 1.2; }
    
    /* Popup Styling */
    .gpx-popup-content { font-family: system-ui, -apple-system, sans-serif; font-size: 0.9rem; line-height: 1.4; }
    .gpx-popup-title { font-weight: bold; margin-bottom: 4px; display: block; border-bottom: 1px solid #eee; padding-bottom: 2px; }
    .gpx-popup-stat { display: block; color: #555; }

    /* Dynamic Marker Styling */
    .gpx-marker-start { background-color: {{ $markerStartColor }}; border: 2px solid #fff; border-radius: 50%; box-shadow: 0 0 4px rgba(0,0,0,0.4); }
    .gpx-marker-end { background-color: {{ $markerEndColor }}; border: 2px solid #fff; border-radius: 2px; box-shadow: 0 0 4px rgba(0,0,0,0.4); }
  </style>

  <div class="gpx-map-container" style="width: {{ $width }}; margin: 0 auto;">
    <div id="{{ $id }}" class="gpx-map {{ if eq $theme "dark" }}dark-theme{{ end }}" style="width: 100%; height: {{ $height }}; border: 1px solid #ddd; border-radius: 8px; overflow: hidden; position: relative; background: #f0f0f0;">
      <div class="gpx-loading" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #666; text-align: center; pointer-events: none; z-index: 1000;">
        <div style="font-size: 2rem; margin-bottom: 0.5rem;">üó∫Ô∏è</div>
        <div>{{ $txtLoading }}</div>
      </div>
    </div>
    
    <div class="gpx-route-selector" style="margin-top: 1rem; display: none;" id="{{ $id }}-route-selector">
      <div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 1rem;">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">
          <h4 style="margin: 0; color: #495057; font-size: 1.1rem;">üó∫Ô∏è {{ $txtRoutes }}</h4>
          <div class="gpx-route-controls">
            <button class="gpx-btn" onclick="window.gpxMaps['{{ $id }}']?.showAllRoutes()" style="background: #28a745; color: white; border: none; border-radius: 4px; padding: 0.25rem 0.5rem; margin-right: 0.25rem; cursor: pointer; font-size: 0.8rem;">{{ $txtAll }}</button>
            <button class="gpx-btn" onclick="window.gpxMaps['{{ $id }}']?.hideAllRoutes()" style="background: #dc3545; color: white; border: none; border-radius: 4px; padding: 0.25rem 0.5rem; margin-right: 0.25rem; cursor: pointer; font-size: 0.8rem;">{{ $txtNone }}</button>
            <button class="gpx-btn" onclick="window.gpxMaps['{{ $id }}']?.fitToVisibleRoutes()" style="background: #007bff; color: white; border: none; border-radius: 4px; padding: 0.25rem 0.5rem; cursor: pointer; font-size: 0.8rem;">üìç {{ $txtFocus }}</button>
          </div>
        </div>
        <div class="gpx-route-list" id="{{ $id }}-routes"></div>
      </div>
    </div>
    
    {{- if eq $showStats "true" -}}
      <div class="gpx-stats" id="{{ $id }}-stats" style="margin-top: 1rem; display: none;">
        <div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 1rem;">
          <h4 style="margin: 0 0 0.75rem 0; color: #495057; font-size: 1.1rem;">üìä {{ $txtSummary }}</h4>
          <div class="stats-grid">
            <div class="stat-item" style="text-align: center; padding: 0.75rem; background: white; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
              <div class="stat-value" data-stat="distance" style="font-weight: bold; color: #28a745; font-size: 1.4rem;">--</div>
              <div class="stat-label" style="color: #6c757d; font-size: 0.85rem;">{{ $txtDist }} (km)</div>
            </div>
            <div class="stat-item" style="text-align: center; padding: 0.75rem; background: white; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: flex; flex-direction: column; justify-content: center;">
              <div class="stat-value" data-stat="elevation" style="font-weight: bold; width: 100%;">--</div>
              <div class="stat-label" style="color: #6c757d; font-size: 0.85rem; margin-top: 4px;">{{ $txtEle }}</div>
            </div>
            <div class="stat-item" style="text-align: center; padding: 0.75rem; background: white; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
              <div class="stat-value" data-stat="time" style="font-weight: bold; color: #6610f2; font-size: 1.4rem;">--</div>
              <div class="stat-label" style="color: #6c757d; font-size: 0.85rem;">{{ $txtTime }}</div>
            </div>
            <div class="stat-item" style="text-align: center; padding: 0.75rem; background: white; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
              <div class="stat-value" data-stat="routeCount" style="font-weight: bold; color: #007bff; font-size: 1.4rem;">--</div>
              <div class="stat-label" style="color: #6c757d; font-size: 0.85rem;">{{ $txtRouteCount }}</div>
            </div>
          </div>
        </div>
      </div>
    {{- end -}}
  </div>

  <script>
  (function() {
    'use strict';

    class GPXMapHandler {
      constructor(mapId, statsId, gpxFiles, showStats, showMarkers, theme) {
        this.mapId = mapId;
        this.statsId = statsId;
        this.gpxFiles = gpxFiles;
        this.showStats = showStats;
        this.showMarkers = showMarkers; 
        this.theme = theme;
        this.map = null;
        this.routeLayers = new Map(); 
        this.markerLayers = new Map(); 
        this.routeData = new Map();
        this.routeStats = new Map();
        this.colorIndex = 0;
        this.colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e', '#f1c40f', '#e91e63'];
      }

      /* --- INITIALIZATION --- */
      async init() {
        // Wait for Leaflet to load if necessary
        if (typeof L === 'undefined') { setTimeout(() => this.init(), 50); return; }
        try {
            await this.initMap();
            await this.loadGPXFiles();
        } catch (err) { console.error("GPX Map Init Error:", err); }
      }

      async initMap() {
        return new Promise((resolve, reject) => {
          const el = document.getElementById(this.mapId);
          if (!el) return reject('Map element not found');
          
          // Enable 'preferCanvas' for better performance with large GPX files
          this.map = L.map(this.mapId, {
            zoomControl: false, attributionControl: true, preferCanvas: true, 
            zoomAnimation: true, markerZoomAnimation: true, fadeAnimation: true, inertia: true
          });

          // Tile Layers
          const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '¬© OpenStreetMap' });
          const topo = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', { maxZoom: 17, attribution: '¬© OpenTopoMap' });
          const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: '¬© Esri' });

          osm.addTo(this.map);
          L.control.layers({ "Map (Standard)": osm, "Topographic": topo, "Satellite": satellite }, null, { position: 'topright' }).addTo(this.map);

          this.map.setView([48.2082, 16.3738], 8); // Default view
          this.setupResizeHandling();
          resolve();
        });
      }

      /* --- GPX LOADING & PARSING --- */
      async loadGPXFiles() {
        const promises = this.gpxFiles.map((file, index) => 
            this.loadSingleGPX(file, index).catch(e => console.warn('Could not load GPX: ' + file, e))
        );
        await Promise.allSettled(promises);
        
        // Remove loading spinner
        const loader = document.querySelector(`#${this.mapId} .gpx-loading`);
        if(loader) loader.style.display = 'none';
        
        this.createRouteSelector();
        this.fitToRoutes();
        if (this.showStats) this.calculateAndShowTotalStats();
      }

      async loadSingleGPX(file, index) {
        const response = await fetch(file);
        if(!response.ok) throw new Error(`HTTP ${response.status}`);
        
        // Parse XML
        const gpxText = await response.text();
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');

        // Extract points (lat, lon, ele, time)
        const parsePoints = (pts) => Array.from(pts).map(point => {
            const ele = parseFloat(point.querySelector('ele')?.textContent || '0');
            const timeNode = point.querySelector('time');
            const time = timeNode ? new Date(timeNode.textContent).getTime() : null;
            return { lat: parseFloat(point.getAttribute('lat')), lon: parseFloat(point.getAttribute('lon')), ele: ele, time: time };
        }).filter(p => !isNaN(p.lat));

        // Parse Tracks and Routes
        const tracks = Array.from(xmlDoc.querySelectorAll('trk')).map(trk => {
          const name = trk.querySelector('name')?.textContent || `Track ${index+1}`;
          const segments = Array.from(trk.querySelectorAll('trkseg')).map(seg => parsePoints(seg.querySelectorAll('trkpt'))).filter(s => s.length > 0);
          return { name, segments };
        }).filter(t => t.segments.length > 0);

        const routes = Array.from(xmlDoc.querySelectorAll('rte')).map(rte => {
          const name = rte.querySelector('name')?.textContent || `Route ${index+1}`;
          const points = parsePoints(rte.querySelectorAll('rtept'));
          return { name, points };
        }).filter(r => r.points.length > 0);

        if (!tracks.length && !routes.length) return;

        // Convert to GeoJSON
        const geojson = { type: 'FeatureCollection', features: [] };
        const addFeatures = (list, isRoute) => list.forEach(item => {
             const coords = isRoute ? item.points : item.segments.flat(); 
             const geometry = isRoute 
                ? { type: 'LineString', coordinates: coords.map(p => [p.lon, p.lat, p.ele, p.time]) }
                : { type: 'MultiLineString', coordinates: item.segments.map(s => s.map(p => [p.lon, p.lat, p.ele, p.time])) };
             
             if(!isRoute) {
                 item.segments.forEach(seg => {
                     geojson.features.push({
                        type: 'Feature', properties: { name: item.name },
                        geometry: { type: 'LineString', coordinates: seg.map(p => [p.lon, p.lat, p.ele, p.time]) }
                     });
                 });
             } else {
                 geojson.features.push({ type: 'Feature', properties: { name: item.name }, geometry });
             }
        });

        addFeatures(tracks, false);
        addFeatures(routes, true);

        // Store Stats & Data (Key = Index to preserve order)
        const stats = this.calculateRouteStats(geojson);
        this.routeStats.set(index, stats);
        this.routeData.set(index, { geojson, color: this.colors[this.colorIndex++ % this.colors.length], originalFile: file, name: this.getFileName(file) });
        
        // Add Map Layer
        const color = this.routeData.get(index).color;
        const layer = L.geoJSON(geojson, {
          style: { color: color, weight: 4, opacity: 0.8, lineCap: 'round', lineJoin: 'round' }, smoothFactor: 1.0 
        }).addTo(this.map);
        this.routeLayers.set(index, layer);

        // Add Markers if enabled
        if (this.showMarkers) {
            this.addStartEndMarkers(index, geojson);
        }

        // Add Popup
        const routeName = tracks[0]?.name || routes[0]?.name || this.getFileName(file);
        const popupContent = `
            <div class="gpx-popup-content">
                <span class="gpx-popup-title">${routeName}</span>
                <span class="gpx-popup-stat">üìè Dist: <b>${stats.distance.toFixed(1)} km</b></span>
                <span class="gpx-popup-stat">üèîÔ∏è Elev: <span style="color:#28a745">‚Üó ${stats.elevationGain}m</span> <span style="color:#dc3545">‚Üò ${stats.elevationLoss}m</span></span>
            </div>
        `;
        layer.bindPopup(popupContent);
      }

      /* --- MARKERS --- */
      addStartEndMarkers(index, geojson) {
          const markers = L.layerGroup();
          geojson.features.forEach(f => {
              const coords = f.geometry.coordinates;
              const flat = (f.geometry.type === 'MultiLineString') ? coords.flat() : coords;
              if (flat.length > 0) {
                  const start = flat[0];
                  const end = flat[flat.length - 1];
                  
                  // Start: Circle
                  L.marker([start[1], start[0]], {
                      icon: L.divIcon({ className: 'gpx-marker-start', html: '', iconSize: [12, 12], iconAnchor: [6, 6] }),
                      interactive: false
                  }).addTo(markers);

                  // End: Square
                  L.marker([end[1], end[0]], {
                      icon: L.divIcon({ className: 'gpx-marker-end', html: '', iconSize: [12, 12], iconAnchor: [6, 6] }),
                      interactive: false
                  }).addTo(markers);
              }
          });
          markers.addTo(this.map);
          this.markerLayers.set(index, markers);
      }

      /* --- STATISTICS CALCULATION --- */
      calculateRouteStats(geojson) {
        let d=0, eg=0, el=0, hp=-Infinity, startTime=null, endTime=null;
        const ELEVATION_THRESHOLD = 5; // Ignore noise < 5m

        geojson.features.forEach(f => {
          const coords = f.geometry.coordinates; 
          const flatCoords = (f.geometry.type === 'MultiLineString') ? coords.flat() : coords;
          if(flatCoords.length === 0) return;

          const t1 = flatCoords[0][3];
          const t2 = flatCoords[flatCoords.length-1][3];
          if(t1 && (!startTime || t1 < startTime)) startTime = t1;
          if(t2 && (!endTime || t2 > endTime)) endTime = t2;
          
          let prevEle = flatCoords[0][2] || 0; 
          for(let i=1; i<flatCoords.length; i++) {
             const [lon1, lat1, ele1] = flatCoords[i-1];
             const [lon2, lat2, ele2] = flatCoords[i];
             
             // Haversine Distance
             const R = 6371e3;
             const œÜ1=lat1*Math.PI/180, œÜ2=lat2*Math.PI/180, ŒîœÜ=(lat2-lat1)*Math.PI/180, ŒîŒª=(lon2-lon1)*Math.PI/180;
             const a = Math.sin(ŒîœÜ/2)**2 + Math.cos(œÜ1)*Math.cos(œÜ2) * Math.sin(ŒîŒª/2)**2;
             d += R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
             
             // Elevation with Thresholding
             const currentEle = ele2 || 0;
             const diff = currentEle - prevEle;
             if (Math.abs(diff) >= ELEVATION_THRESHOLD) {
                 if(diff > 0) eg += diff; else el += Math.abs(diff);
                 prevEle = currentEle; 
             }
             hp = Math.max(hp, currentEle);
          }
        });
        return { 
            distance: d/1000, 
            elevationGain: Math.round(eg), 
            elevationLoss: Math.round(el), 
            highestPoint: Math.round(hp === -Infinity ? 0 : hp), 
            duration: (startTime && endTime) ? (endTime - startTime) : 0 
        };
      }

      formatTime(ms) {
          if(!ms || ms <= 0) return "--:--";
          const totalMinutes = Math.floor(ms / 60000);
          const hours = Math.floor(totalMinutes / 60);
          const minutes = totalMinutes % 60;
          return `${hours.toString().padStart(2,'0')}:${minutes.toString().padStart(2,'0')}h`;
      }

      /* --- UI & INTERACTION --- */
      createRouteSelector() {
        const list = document.getElementById(this.mapId+'-routes');
        const sel = document.getElementById(this.mapId+'-route-selector');
        if(!list) return;
        
        if(this.routeData.size > 0 && sel) sel.style.display = 'block';
        list.innerHTML = '';
        
        // Sort keys to ensure file order matches config (0, 1, 2...)
        const sortedIds = Array.from(this.routeData.keys()).sort((a, b) => a - b);

        sortedIds.forEach(id => {
          const d = this.routeData.get(id);
          const s = this.routeStats.get(id);
          const visible = this.map.hasLayer(this.routeLayers.get(id));
          
          const div = document.createElement('div');
          div.style.cssText = `display:flex;align-items:center;padding:0.5rem;background:white;border-radius:4px;border:1px solid #eee;border-left:5px solid ${visible ? d.color : '#ccc'}; transition: background 0.2s;`;
          
          // Hover Effects
          div.onmouseenter = () => this.highlightRoute(id, true);
          div.onmouseleave = () => this.highlightRoute(id, false);

          const timeStr = s.duration ? `<span class="route-stat-pill" title="Duration">‚è± ${this.formatTime(s.duration)}</span>` : '';
          
          div.innerHTML = `
            <input type="checkbox" ${visible?'checked':''} onchange="window.gpxMaps['${this.mapId}'].toggleRoute(${id})" style="margin-right:10px; cursor:pointer;">
            <div style="flex:1;overflow:hidden;margin-right:10px;">
                <div style="font-weight:600;font-size:0.95rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis" title="${d.name}">${d.name}</div>
                <div class="route-details">
                    <span class="route-stat-pill" title="Distance">üìè ${s.distance.toFixed(1)} km</span>
                    <span class="route-stat-pill" style="color:#28a745" title="Gain">‚Üó ${s.elevationGain}m</span>
                    <span class="route-stat-pill" style="color:#dc3545" title="Loss">‚Üò ${s.elevationLoss}m</span>
                    ${timeStr}
                </div>
            </div>
            <button onclick="window.gpxMaps['${this.mapId}'].downloadGPX(${id})" title="Download GPX" style="background:transparent;color:#007bff;border:1px solid #cce5ff;border-radius:4px;padding:2px 6px;cursor:pointer;font-size:1.1rem;">üì•</button>
          `;
          list.appendChild(div);
        });
      }

      highlightRoute(id, active) {
          const layer = this.routeLayers.get(id);
          if (layer && this.map.hasLayer(layer)) {
              layer.setStyle({ weight: active ? 7 : 4, opacity: active ? 1.0 : 0.8 });
              if (active) layer.bringToFront();
          }
      }

      toggleRoute(id) {
        const l = this.routeLayers.get(id);
        const m = this.markerLayers.get(id);
        if(!l) return; 

        if(this.map.hasLayer(l)) {
            this.map.removeLayer(l);
            if(m) this.map.removeLayer(m);
        } else {
            this.map.addLayer(l);
            if(m) this.map.addLayer(m);
        }
        
        this.createRouteSelector(); 
        if(this.showStats) this.calculateAndShowTotalStats();
      }
      
      showAllRoutes() { 
          this.routeLayers.forEach((l, id) => { 
              if(!this.map.hasLayer(l)) { this.map.addLayer(l); }
              const m = this.markerLayers.get(id);
              if(m && !this.map.hasLayer(m)) this.map.addLayer(m);
          }); 
          this.createRouteSelector(); 
          this.calculateAndShowTotalStats(); 
          this.fitToRoutes(); 
      }
      
      hideAllRoutes() { 
          this.routeLayers.forEach((l, id) => { 
              if(this.map.hasLayer(l)) this.map.removeLayer(l); 
              const m = this.markerLayers.get(id);
              if(m && this.map.hasLayer(m)) this.map.removeLayer(m);
          }); 
          this.createRouteSelector(); 
          this.calculateAndShowTotalStats(); 
      }
      
      fitToRoutes() {
        const layers = [];
        this.routeLayers.forEach(l => { if(this.map.hasLayer(l)) layers.push(l); });
        // Smooth Zoom
        if(layers.length) this.map.flyToBounds(L.featureGroup(layers).getBounds(), {padding:[20,20], duration: 1.5});
      }

      calculateAndShowTotalStats() {
        const el = document.getElementById(this.statsId);
        if(!el) return;
        let d=0, eg=0, eloss=0, c=0, time=0;
        this.routeLayers.forEach((l, id) => {
           if(this.map.hasLayer(l)) {
             c++; const s = this.routeStats.get(id);
             if(s) { d+=s.distance; eg+=s.elevationGain; eloss+=s.elevationLoss; if(s.duration) time+=s.duration; }
           }
        });
        el.querySelector('[data-stat="distance"]').textContent = d.toFixed(2);
        el.querySelector('[data-stat="elevation"]').innerHTML = `<div class="stat-elevation-detail"><span style="color:#28a745">‚Üó ${eg}m</span><span style="color:#dc3545">‚Üò ${eloss}m</span></div>`;
        el.querySelector('[data-stat="time"]').textContent = this.formatTime(time);
        el.querySelector('[data-stat="routeCount"]').textContent = c;
        el.style.display = c > 0 ? 'block' : 'none';
      }

      getFileName(f) { return f.split('/').pop().replace('.gpx', '').replace(/[-_]/g, ' '); }
      
      downloadGPX(id) {
         const path = this.routeData.get(id)?.originalFile;
         if(!path) return;
         fetch(path).then(r=>r.text()).then(t=> {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([t],{type:'application/gpx+xml'}));
            a.download = path.split('/').pop();
            a.click();
         });
      }
      
      setupResizeHandling() { 
          window.addEventListener('resize', ()=> this.map && this.map.invalidateSize());
          const el = document.getElementById(this.mapId);
          if(el && typeof ResizeObserver !== 'undefined') {
              const resizeObserver = new ResizeObserver(() => { if(this.map) { this.map.invalidateSize(); } });
              resizeObserver.observe(el);
          }
          setTimeout(() => this.map && this.map.invalidateSize(), 500); 
      }
      
      fitToVisibleRoutes() { this.fitToRoutes(); }
    }

    /* --- BOOTSTRAP --- */
    const gpxFilesRaw = [];
    {{- range $gpxFiles -}}gpxFilesRaw.push("{{ . }}");{{- end -}}
    
    const handler = new GPXMapHandler('{{ $id }}', '{{ $id }}-stats', gpxFilesRaw, {{ $showStats }}, {{ $showMarkers }}, '{{ $theme }}');
    if(!window.gpxMaps) window.gpxMaps = {};
    window.gpxMaps['{{ $id }}'] = handler;

    // Lazy Loading via IntersectionObserver
    const initMapOnView = () => {
        const target = document.getElementById('{{ $id }}');
        if (!('IntersectionObserver' in window)) { handler.init(); return; }
        const observer = new IntersectionObserver((entries, obs) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    handler.init();
                    obs.unobserve(entry.target);
                }
            });
        }, { rootMargin: "200px" });
        if (target) observer.observe(target);
    };

    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initMapOnView); } else { initMapOnView(); }
  })();
  </script>
{{- end -}}