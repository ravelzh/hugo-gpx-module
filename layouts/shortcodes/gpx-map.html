{{- /* --- 1. LANGUAGE SETTINGS --- */ -}}
{{- $lang := .Page.Lang | default "en" -}}
{{- $txtSummary := cond (eq $lang "de") "Zusammenfassung" "Summary" -}}
{{- $txtRoutes := cond (eq $lang "de") "Routen-Auswahl" "Route Selection" -}}
{{- $txtDist := cond (eq $lang "de") "Distanz" "Distance" -}}
{{- $txtEle := cond (eq $lang "de") "H√∂henmeter" "Elevation" -}}
{{- $txtTime := cond (eq $lang "de") "Gesamtzeit" "Total Time" -}}
{{- $txtRouteCount := cond (eq $lang "de") "Routen" "Routes" -}}
{{- $txtAll := cond (eq $lang "de") "Alle" "All" -}}
{{- $txtNone := cond (eq $lang "de") "Keine" "None" -}}
{{- $txtFocus := cond (eq $lang "de") "Fokus" "Focus" -}}
{{- $txtProfile := cond (eq $lang "de") "Profil" "Profile" -}}
{{- $txtLoading := cond (eq $lang "de") "Karte wird geladen..." "Loading map..." -}}
{{- $txtError := cond (eq $lang "de") "Fehler" "Error" -}}
{{- $txtErrorMsg := cond (eq $lang "de") "Mindestens eine GPX-Datei erforderlich." "At least one GPX file is required." -}}

{{- /* --- 2. GLOBAL CONFIGURATION & DEFAULTS --- */ -}}
{{- $gpxConf := site.Params.gpx | default dict -}}

{{- /* UI Dimensions */ -}}
{{- $width := .Get "width" | default ($gpxConf.width | default "100%") -}}
{{- $height := .Get "height" | default ($gpxConf.height | default "600px") -}}
{{- $routeMinWidth := .Get "route-min-width" | default ($gpxConf.routeMinWidth | default "380px") -}}
{{- $statMinWidth := .Get "stat-min-width" | default ($gpxConf.statMinWidth | default "110px") -}}
{{- $id := printf "gpx-map-%d" .Ordinal -}}

{{- /* Features (Stats/Controls) */ -}}
{{- $defStats := index $gpxConf "showStats" | default "true" -}}
{{- $showStats := .Get "show-stats" | default $defStats -}}

{{- /* Elevation Profile Config */ -}}
{{- $defEle := index $gpxConf "elevation" | default "true" -}}
{{- $showElevation := .Get "elevation" | default $defEle -}}
{{- $eleHeight := .Get "elevation-height" | default ($gpxConf.elevationHeight | default "150px") -}}
{{- $eleColor := .Get "elevation-color" | default ($gpxConf.elevationColor | default "#2980b9") -}}

{{- /* Marker Config */ -}}
{{- $defMarkers := index $gpxConf "markers" | default "true" -}}
{{- $showMarkers := .Get "markers" | default $defMarkers -}}
{{- $markerStartColor := .Get "marker-start-color" | default ($gpxConf.markerStartColor | default "#2ecc71") -}}
{{- $markerEndColor := .Get "marker-end-color" | default ($gpxConf.markerEndColor | default "#e74c3c") -}}

{{- /* Track Line Style */ -}}
{{- $lineWeight := $gpxConf.lineWeight | default 4 -}}
{{- $lineOpacity := $gpxConf.lineOpacity | default 0.8 -}}
{{- /* Track Colors (Array as string for JS) */ -}}
{{- $colorList := $gpxConf.trackColors | default (slice "#e74c3c" "#3498db" "#2ecc71" "#f39c12" "#9b59b6" "#1abc9c" "#e67e22" "#34495e" "#f1c40f" "#e91e63") -}}

{{- /* Map Default View */ -}}
{{- $startLat := $gpxConf.startLat | default 48.2082 -}}
{{- $startLon := $gpxConf.startLon | default 16.3738 -}}
{{- $startZoom := $gpxConf.startZoom | default 8 -}}

{{- /* Map Provider Configuration (Tile Layers) */ -}}
{{- $osmUrl := $gpxConf.osmUrl | default "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png" -}}
{{- $osmAttr := $gpxConf.osmAttr | default "¬© OpenStreetMap" -}}
{{- $topoUrl := $gpxConf.topoUrl | default "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png" -}}
{{- $topoAttr := $gpxConf.topoAttr | default "¬© OpenTopoMap" -}}
{{- $satUrl := $gpxConf.satUrl | default "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}" -}}
{{- $satAttr := $gpxConf.satAttr | default "¬© Esri" -}}
{{- /* Default active layer: 'osm', 'topo', 'satellite' */ -}}
{{- $defaultLayer := $gpxConf.defaultLayer | default "osm" -}}

{{- /* --- 3. GPX FILE PARSING --- */ -}}
{{- $gpxFiles := slice -}}
{{- if .IsNamedParams -}}
  {{- if .Get "file" -}}{{- $gpxFiles = $gpxFiles | append (.Get "file") -}}{{- end -}}
  {{- range $i := seq 2 20 -}}
    {{- $key := printf "file%d" $i -}}
    {{- if $.Get $key -}}{{- $gpxFiles = $gpxFiles | append ($.Get $key) -}}{{- end -}}
  {{- end -}}
{{- else -}}
  {{- range .Params -}}{{- $gpxFiles = $gpxFiles | append . -}}{{- end -}}
{{- end -}}

{{- if eq (len $gpxFiles) 0 -}}
  <div class="gpx-error" style="padding: 1rem; color: #c00; background: #fee; border: 1px solid #fcc; border-radius: 4px;">
    <strong>{{ $txtError }}:</strong> {{ $txtErrorMsg }}
  </div>
{{- else -}}

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="https://unpkg.com/d3@7.9.0/dist/d3.min.js"></script>
  
  <style>
    /* --- CSS Styles --- */
    .gpx-map-container, .gpx-map-container .leaflet-container { z-index: 1 !important; position: relative !important; isolation: isolate; }
    header, nav, .navbar, .menu, .modal, .lightbox, .fancybox-container, .pswp, .gallery-overlay, .overlay { z-index: 2147483647 !important; position: relative; }
    header.fixed, .navbar.fixed-top { position: fixed !important; }
    .gpx-map-container * { color-scheme: light !important; forced-color-adjust: none !important; box-sizing: border-box; }
    .gpx-map-container { text-align: left !important; font-family: system-ui, -apple-system, sans-serif; color: #333 !important; }
    .gpx-box-style { background: #f8f9fa !important; border: 1px solid #dee2e6 !important; color: #333 !important; }
    .gpx-item-style { background: #ffffff !important; border: 1px solid #eee; color: #333 !important; }
    .gpx-text-dark { color: #333 !important; }
    .gpx-text-muted { color: #666 !important; }
    #{{ $id }} .leaflet-pane, #{{ $id }} .leaflet-tile, #{{ $id }} .leaflet-marker-icon { max-width: none !important; max-height: none !important; margin: 0 !important; padding: 0 !important; box-shadow: none !important; border: none !important; }
    .leaflet-popup-content-wrapper, .leaflet-popup-tip { background: white !important; color: #333 !important; }
    .gpx-popup-title { font-weight: bold; border-bottom: 1px solid #eee; padding-bottom: 2px; color: #000 !important; display: block; }
    #{{ $id }}-routes { display: grid; grid-template-columns: repeat(auto-fit, minmax({{ $routeMinWidth }}, 1fr)); gap: 0.5rem; }
    .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax({{ $statMinWidth }}, 1fr)); gap: 0.5rem; }
    .route-details { font-size: 0.8rem; margin-top: 2px; display: flex; flex-wrap: wrap; gap: 8px; }
    .route-stat-pill { display: inline-flex; align-items: center; gap: 3px; white-space: nowrap; }
    .elevation-chart-wrapper { background: #ffffff !important; border: 1px solid #ddd !important; border-radius: 8px; padding: 0; margin-top: 10px; position: relative; display: none; overflow: hidden; }
    .elevation-chart-wrapper svg text, .elevation-chart-wrapper .tick text, .elevation-chart-wrapper .axis text { fill: #000000 !important; stroke: none !important; color: #000000 !important; -webkit-text-fill-color: #000000 !important; font-family: sans-serif !important; font-size: 10px !important; font-weight: normal !important; }
    .elevation-chart-wrapper path.domain, .elevation-chart-wrapper line { stroke: #333333 !important; }
    .elevation-chart-wrapper .tick line { stroke: #cccccc !important; }
    .elevation-focus-circle { stroke: #fff; stroke-width: 2px; pointer-events: none; }
    .elevation-focus-line { stroke: #666; stroke-width: 1px; stroke-dasharray: 4; pointer-events: none; }
    .elevation-tooltip { position: absolute; background-color: rgba(255, 255, 255, 0.95) !important; color: #000000 !important; padding: 4px 8px; border: 1px solid #ccc !important; border-radius: 4px; font-size: 0.8rem; pointer-events: none; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: none; white-space: nowrap; z-index: 20; }
    .elevation-tooltip * { color: #000000 !important; -webkit-text-fill-color: #000000 !important; }
    .gpx-marker-start { background-color: {{ $markerStartColor }}; border: 2px solid #fff; border-radius: 50%; box-shadow: 0 0 4px rgba(0,0,0,0.4); }
    .gpx-marker-end { background-color: {{ $markerEndColor }}; border: 2px solid #fff; border-radius: 2px; box-shadow: 0 0 4px rgba(0,0,0,0.4); }
  </style>

  <div class="gpx-map-container" style="width: {{ $width }}; margin: 0 auto;">
    
    <div id="{{ $id }}" class="gpx-map" style="width: 100%; height: {{ $height }}; border: 1px solid #ddd; border-radius: 8px; overflow: hidden; position: relative; background: #f0f0f0 !important;">
      <div class="gpx-loading" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #666; text-align: center; pointer-events: none; z-index: 1000;">
        <div style="font-size: 2rem; margin-bottom: 0.5rem;">üó∫Ô∏è</div>
        <div>{{ $txtLoading }}</div>
      </div>
    </div>
    
    <div id="{{ $id }}-elevation" class="elevation-chart-wrapper" style="height: {{ $eleHeight }};">
        <div class="elevation-tooltip" id="{{ $id }}-ele-tooltip"></div>
    </div>

    <div class="gpx-route-selector" style="margin-top: 1rem; display: none;" id="{{ $id }}-route-selector">
      <div class="gpx-box-style" style="border-radius: 8px; padding: 1rem;">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">
          <h4 style="margin: 0; font-size: 1.1rem; color: #495057 !important;">üó∫Ô∏è {{ $txtRoutes }}</h4>
          <div class="gpx-route-controls">
            <button class="gpx-btn" id="{{ $id }}-btn-ele" onclick="window.gpxMaps['{{ $id }}']?.toggleElevation()" style="background: #6c757d; color: white; border: none; border-radius: 4px; padding: 0.25rem 0.5rem; margin-right: 0.25rem; cursor: pointer; font-size: 0.8rem;">üìà {{ $txtProfile }}</button>
            <button class="gpx-btn" onclick="window.gpxMaps['{{ $id }}']?.showAllRoutes()" style="background: #28a745; color: white; border: none; border-radius: 4px; padding: 0.25rem 0.5rem; margin-right: 0.25rem; cursor: pointer; font-size: 0.8rem;">{{ $txtAll }}</button>
            <button class="gpx-btn" onclick="window.gpxMaps['{{ $id }}']?.hideAllRoutes()" style="background: #dc3545; color: white; border: none; border-radius: 4px; padding: 0.25rem 0.5rem; margin-right: 0.25rem; cursor: pointer; font-size: 0.8rem;">{{ $txtNone }}</button>
            <button class="gpx-btn" onclick="window.gpxMaps['{{ $id }}']?.fitToVisibleRoutes()" style="background: #007bff; color: white; border: none; border-radius: 4px; padding: 0.25rem 0.5rem; cursor: pointer; font-size: 0.8rem;">üìç {{ $txtFocus }}</button>
          </div>
        </div>
        <div class="gpx-route-list" id="{{ $id }}-routes"></div>
      </div>
    </div>

    {{- if eq (printf "%v" $showStats) "true" -}}
      <div class="gpx-stats" id="{{ $id }}-stats" style="margin-top: 1rem; display: none;">
        <div class="gpx-box-style" style="border-radius: 8px; padding: 1rem;">
          <h4 style="margin: 0 0 0.75rem 0; font-size: 1.1rem; color: #495057 !important;">üìä {{ $txtSummary }}</h4>
          <div class="stats-grid">
            <div class="stat-item gpx-item-style" style="text-align: center; padding: 0.75rem; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
              <div class="stat-value" data-stat="distance" style="font-weight: bold; color: #28a745 !important; font-size: 1.4rem;">--</div>
              <div class="stat-label gpx-text-muted" style="font-size: 0.85rem;">{{ $txtDist }} (km)</div>
            </div>
            <div class="stat-item gpx-item-style" style="text-align: center; padding: 0.75rem; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: flex; flex-direction: column; justify-content: center;">
              <div class="stat-value" data-stat="elevation" style="font-weight: bold; width: 100%;">--</div>
              <div class="stat-label gpx-text-muted" style="font-size: 0.85rem; margin-top: 4px;">{{ $txtEle }}</div>
            </div>
            <div class="stat-item gpx-item-style" style="text-align: center; padding: 0.75rem; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
              <div class="stat-value" data-stat="time" style="font-weight: bold; color: #6610f2 !important; font-size: 1.4rem;">--</div>
              <div class="stat-label gpx-text-muted" style="font-size: 0.85rem;">{{ $txtTime }}</div>
            </div>
            <div class="stat-item gpx-item-style" style="text-align: center; padding: 0.75rem; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
              <div class="stat-value" data-stat="routeCount" style="font-weight: bold; color: #007bff !important; font-size: 1.4rem;">--</div>
              <div class="stat-label gpx-text-muted" style="font-size: 0.85rem;">{{ $txtRouteCount }}</div>
            </div>
          </div>
        </div>
      </div>
    {{- end -}}
  </div>

  <script>
  (function() {
    'use strict';

    class GPXMapHandler {
      constructor(mapId, statsId, gpxFiles, config) {
        this.mapId = mapId;
        this.statsId = statsId;
        this.gpxFiles = gpxFiles;
        this.config = config; 
        
        this.map = null;
        this.routeLayers = new Map(); 
        this.markerLayers = new Map(); 
        this.routeData = new Map();
        this.routeStats = new Map();
        this.colorIndex = 0;
        
        // Use Global colors or Fallback
        this.colors = config.colors && config.colors.length ? config.colors : ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6'];
        
        this.focusMarker = null; 
        this.isElevationVisible = this.config.ele.active; 
      }

      async init() {
        if (typeof L === 'undefined') { setTimeout(() => this.init(), 50); return; }
        try { await this.initMap(); await this.loadGPXFiles(); } 
        catch (err) { console.error("GPX Init Error:", err); }
      }

      async initMap() {
        return new Promise((resolve, reject) => {
          const el = document.getElementById(this.mapId);
          if (!el) return reject('Map element missing');
          
          this.map = L.map(this.mapId, {
            zoomControl: false, attributionControl: true, preferCanvas: true, 
            zoomAnimation: true, markerZoomAnimation: true, fadeAnimation: true, inertia: true
          });

          // Dynamic Tile Layers from Config
          const osm = L.tileLayer(this.config.tiles.osm.url, { maxZoom: 19, attribution: this.config.tiles.osm.attr });
          const topo = L.tileLayer(this.config.tiles.topo.url, { maxZoom: 17, attribution: this.config.tiles.topo.attr });
          const satellite = L.tileLayer(this.config.tiles.sat.url, { attribution: this.config.tiles.sat.attr });

          const baseMaps = { "Standard": osm, "Topographic": topo, "Satellite": satellite };

          // Set default layer
          if(this.config.defaultLayer === 'satellite') satellite.addTo(this.map);
          else if(this.config.defaultLayer === 'topo') topo.addTo(this.map);
          else osm.addTo(this.map);

          L.control.layers(baseMaps, null, { position: 'topright' }).addTo(this.map);

          // Default View
          this.map.setView([this.config.view.lat, this.config.view.lon], this.config.view.zoom); 
          this.setupResizeHandling();
          resolve();
        });
      }

      _getDistance(lat1, lon1, lat2, lon2) {
          const R = 6371e3; const œÜ1 = lat1 * Math.PI / 180; const œÜ2 = lat2 * Math.PI / 180;
          const ŒîœÜ = (lat2 - lat1) * Math.PI / 180; const ŒîŒª = (lon2 - lon1) * Math.PI / 180;
          const a = Math.sin(ŒîœÜ / 2) ** 2 + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) ** 2;
          return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      }

      async loadGPXFiles() {
        const promises = this.gpxFiles.map((file, index) => 
            this.loadSingleGPX(file, index).catch(e => console.warn('Load failed: ' + file, e))
        );
        await Promise.allSettled(promises);
        
        const loader = document.querySelector(`#${this.mapId} .gpx-loading`);
        if(loader) loader.style.display = 'none';
        
        this.createRouteSelector();
        this.fitToRoutes();
        if (this.config.showStats) this.calculateAndShowTotalStats();
        
        this.updateElevationButton();
        if (this.isElevationVisible) this._drawElevationProfile();
      }

      async loadSingleGPX(file, index) {
        const response = await fetch(file);
        if(!response.ok) throw new Error(`HTTP ${response.status}`);
        
        const gpxText = await response.text();
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');
        
        // Helper to parse points
        const parsePoints = (pts) => Array.from(pts).map(point => {
            const ele = parseFloat(point.querySelector('ele')?.textContent || '0');
            const timeNode = point.querySelector('time');
            return { lat: parseFloat(point.getAttribute('lat')), lon: parseFloat(point.getAttribute('lon')), ele: ele, time: timeNode ? new Date(timeNode.textContent).getTime() : null };
        }).filter(p => !isNaN(p.lat));

        const tracks = Array.from(xmlDoc.querySelectorAll('trk')).map(trk => {
          const name = trk.querySelector('name')?.textContent || `Track ${index+1}`;
          const segments = Array.from(trk.querySelectorAll('trkseg')).map(seg => parsePoints(seg.querySelectorAll('trkpt'))).filter(s => s.length > 0);
          return { name, segments };
        }).filter(t => t.segments.length > 0);

        const routes = Array.from(xmlDoc.querySelectorAll('rte')).map(rte => {
          const name = rte.querySelector('name')?.textContent || `Route ${index+1}`;
          return { name, points: parsePoints(rte.querySelectorAll('rtept')) };
        }).filter(r => r.points.length > 0);

        if (!tracks.length && !routes.length) return;

        const geojson = { type: 'FeatureCollection', features: [] };
        const addFeatures = (list, isRoute) => list.forEach(item => {
             const coords = isRoute ? item.points : item.segments.flat(); 
             const coordinates = isRoute ? coords.map(p => [p.lon, p.lat, p.ele, p.time]) : item.segments.map(s => s.map(p => [p.lon, p.lat, p.ele, p.time]));
             const type = isRoute ? 'LineString' : 'MultiLineString';
             geojson.features.push({ type: 'Feature', properties: { name: item.name }, geometry: { type, coordinates } });
        });
        addFeatures(tracks, false); addFeatures(routes, true);

        const stats = this.calculateRouteStats(geojson);
        this.routeStats.set(index, stats);
        this.routeData.set(index, { geojson, color: this.colors[this.colorIndex++ % this.colors.length], originalFile: file, name: this.getFileName(file) });
        
        // Global style settings used here
        const layer = L.geoJSON(geojson, {
          style: { 
            color: this.routeData.get(index).color, 
            weight: this.config.style.weight, 
            opacity: this.config.style.opacity, 
            lineCap: 'round', lineJoin: 'round' 
          }, smoothFactor: 1.0 
        }).addTo(this.map);
        this.routeLayers.set(index, layer);

        if (this.config.showMarkers) this.addStartEndMarkers(index, geojson);

        const routeName = tracks[0]?.name || routes[0]?.name || this.getFileName(file);
        layer.bindPopup(`
            <div class="gpx-popup-content">
                <span class="gpx-popup-title">${routeName}</span>
                <span class="gpx-popup-stat">üìè Dist: <b>${stats.distance.toFixed(1)} km</b></span>
                <span class="gpx-popup-stat">üèîÔ∏è Elev: <span style="color:#28a745">‚Üó ${stats.elevationGain}m</span> <span style="color:#dc3545">‚Üò ${stats.elevationLoss}m</span></span>
            </div>
        `);
      }

      addStartEndMarkers(index, geojson) {
          const markers = L.layerGroup();
          geojson.features.forEach(f => {
              const coords = f.geometry.coordinates;
              const flat = (f.geometry.type === 'MultiLineString') ? coords.flat() : coords;
              if (flat.length > 0) {
                  const start = flat[0]; const end = flat[flat.length - 1];
                  L.marker([start[1], start[0]], { icon: L.divIcon({ className: 'gpx-marker-start', html: '', iconSize: [12,12] }), interactive:false }).addTo(markers);
                  L.marker([end[1], end[0]], { icon: L.divIcon({ className: 'gpx-marker-end', html: '', iconSize: [12,12] }), interactive:false }).addTo(markers);
              }
          });
          markers.addTo(this.map);
          this.markerLayers.set(index, markers);
      }

      calculateRouteStats(geojson) {
        let d=0, eg=0, el=0, hp=-Infinity, startTime=null, endTime=null;
        const ELEVATION_THRESHOLD = 5; 
        geojson.features.forEach(f => {
          const coords = (f.geometry.type === 'MultiLineString') ? f.geometry.coordinates.flat() : f.geometry.coordinates;
          if(!coords.length) return;
          const t1 = coords[0][3]; const t2 = coords[coords.length-1][3];
          if(t1 && (!startTime || t1 < startTime)) startTime = t1;
          if(t2 && (!endTime || t2 > endTime)) endTime = t2;
          let prevEle = coords[0][2] || 0; 
          for(let i=1; i<coords.length; i++) {
             const [lon1, lat1] = coords[i-1]; const [lon2, lat2, ele2] = coords[i];
             d += this._getDistance(lat1, lon1, lat2, lon2);
             const currentEle = ele2 || 0; const diff = currentEle - prevEle;
             if (Math.abs(diff) >= ELEVATION_THRESHOLD) {
                 if(diff > 0) eg += diff; else el += Math.abs(diff);
                 prevEle = currentEle; 
             }
             hp = Math.max(hp, currentEle);
          }
        });
        return { distance: d/1000, elevationGain: Math.round(eg), elevationLoss: Math.round(el), highestPoint: Math.round(hp === -Infinity ? 0 : hp), duration: (startTime && endTime) ? (endTime - startTime) : 0 };
      }

      _prepareElevationData() {
        let dataPoints = []; let totalDist = 0;
        const visibleIds = Array.from(this.routeData.keys()).sort((a,b)=>a-b);
        visibleIds.forEach(id => {
            const layer = this.routeLayers.get(id);
            if (!this.map.hasLayer(layer)) return;
            const geojson = this.routeData.get(id).geojson;
            geojson.features.forEach(f => {
                const coords = (f.geometry.type === 'MultiLineString') ? f.geometry.coordinates.flat() : f.geometry.coordinates;
                for (let i = 0; i < coords.length; i++) {
                    const [lon, lat, ele] = coords[i];
                    if (i > 0) {
                        const [prevLon, prevLat] = coords[i-1];
                        totalDist += this._getDistance(prevLat, prevLon, lat, lon);
                    }
                    dataPoints.push({ dist: totalDist / 1000, ele: ele || 0, lat: lat, lon: lon });
                }
            });
        });
        return dataPoints;
      }

      toggleElevation() {
          this.isElevationVisible = !this.isElevationVisible;
          this.updateElevationButton();
          if (this.isElevationVisible) this._drawElevationProfile();
          else { document.getElementById(`${this.mapId}-elevation`).style.display = 'none'; if(this.focusMarker) this.focusMarker.remove(); }
      }

      updateElevationButton() {
          const btn = document.getElementById(`${this.mapId}-btn-ele`);
          if (btn) {
             btn.style.backgroundColor = this.isElevationVisible ? '#5a6268' : '#6c757d';
             btn.style.boxShadow = this.isElevationVisible ? 'inset 0 2px 4px rgba(0,0,0,0.2)' : 'none';
          }
      }

      _drawElevationProfile() {
        const containerId = `${this.mapId}-elevation`;
        const container = document.getElementById(containerId);
        const tooltip = document.getElementById(`${this.mapId}-ele-tooltip`);
        if (!this.isElevationVisible) { container.style.display = 'none'; return; }
        const data = this._prepareElevationData();
        if (data.length === 0) { container.style.display = 'none'; if (this.focusMarker) this.focusMarker.remove(); return; }
        container.style.display = 'block';
        d3.select("#" + containerId).selectAll("svg").remove();

        const margin = {top: 10, right: 5, bottom: 20, left: 35};
        const width = container.clientWidth - margin.left - margin.right;
        const height = container.clientHeight - margin.top - margin.bottom; 
        const color = this.config.ele.color;
        const svg = d3.select("#" + containerId).append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", `translate(${margin.left},${margin.top})`);
        const x = d3.scaleLinear().domain(d3.extent(data, d => d.dist)).range([0, width]);
        const yExtent = d3.extent(data, d => d.ele);
        const yPadding = (yExtent[1] - yExtent[0]) * 0.1;
        const y = d3.scaleLinear().domain([yExtent[0] - yPadding, yExtent[1] + yPadding]).range([height, 0]);

        svg.append("path").datum(data).attr("fill", color).attr("fill-opacity", 0.2).attr("stroke", color).attr("stroke-width", 2).attr("d", d3.area().x(d => x(d.dist)).y0(height).y1(d => y(d.ele)));
        svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x).ticks(5).tickFormat(d => d + " km"));
        svg.append("g").call(d3.axisLeft(y).ticks(5));

        const focusCircle = svg.append("circle").attr("class", "elevation-focus-circle").attr("r", 5).attr("fill", this.config.markerEndColor).style("opacity", 0);
        const focusLine = svg.append("line").attr("class", "elevation-focus-line").style("opacity", 0).attr("y1", 0).attr("y2", height);
        if (!this.focusMarker) this.focusMarker = L.circleMarker([0,0], { radius: 6, color: this.config.markerEndColor, fillColor: this.config.markerEndColor, fillOpacity: 1 });

        svg.append("rect").attr("width", width).attr("height", height).style("fill", "none").style("pointer-events", "all")
            .on("mouseover", () => { focusCircle.style("opacity", 1); focusLine.style("opacity", 1); tooltip.style.display = "block"; this.focusMarker.addTo(this.map); })
            .on("mouseout", () => { focusCircle.style("opacity", 0); focusLine.style("opacity", 0); tooltip.style.display = "none"; this.focusMarker.remove(); })
            .on("mousemove", (event) => {
                const xDist = x.invert(d3.pointer(event)[0]);
                const bisect = d3.bisector(d => d.dist).left;
                const idx = bisect(data, xDist, 1);
                const d = data[idx] || data[idx-1];
                if (!d) return;
                focusCircle.attr("cx", x(d.dist)).attr("cy", y(d.ele));
                focusLine.attr("x1", x(d.dist)).attr("x2", x(d.dist));
                let toolLeft = x(d.dist) + 10;
                if(toolLeft + 80 > width) toolLeft = x(d.dist) - 90;
                tooltip.innerHTML = `<strong style="color:#000!important;font-weight:bold;">${d.dist.toFixed(1)} km</strong><br><span style="color:#000!important;">${Math.round(d.ele)} m</span>`;
                tooltip.style.left = toolLeft + "px"; tooltip.style.top = (y(d.ele) - 30) + "px";
                this.focusMarker.setLatLng([d.lat, d.lon]);
            });
      }

      formatTime(ms) {
          if(!ms || ms <= 0) return "--:--";
          const min = Math.floor(ms / 60000);
          return `${Math.floor(min / 60).toString().padStart(2,'0')}:${(min % 60).toString().padStart(2,'0')}h`;
      }

      createRouteSelector() {
        const list = document.getElementById(this.mapId+'-routes');
        const sel = document.getElementById(this.mapId+'-route-selector');
        if(!list) return;
        if(this.routeData.size > 0 && sel) sel.style.display = 'block';
        list.innerHTML = '';
        const sortedIds = Array.from(this.routeData.keys()).sort((a, b) => a - b);

        sortedIds.forEach(id => {
          const d = this.routeData.get(id);
          const s = this.routeStats.get(id);
          const visible = this.map.hasLayer(this.routeLayers.get(id));
          const div = document.createElement('div');
          div.className = 'gpx-item-style'; 
          div.style.cssText = `display:flex;align-items:center;padding:0.5rem;border-radius:4px;border-left:5px solid ${visible ? d.color : '#ccc'}; transition: background 0.2s;`;
          div.onmouseenter = () => this.highlightRoute(id, true);
          div.onmouseleave = () => this.highlightRoute(id, false);
          const timeStr = s.duration ? `<span class="route-stat-pill gpx-text-muted" title="Duration">‚è± ${this.formatTime(s.duration)}</span>` : '';
          
          div.innerHTML = `
            <input type="checkbox" ${visible?'checked':''} onchange="window.gpxMaps['${this.mapId}'].toggleRoute(${id})" style="margin-right:10px; cursor:pointer;">
            <div style="flex:1;overflow:hidden;margin-right:10px;">
                <div style="font-weight:600;font-size:0.95rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#333 !important;" title="${d.name}">${d.name}</div>
                <div class="route-details">
                    <span class="route-stat-pill gpx-text-muted">üìè ${s.distance.toFixed(1)} km</span>
                    <span class="route-stat-pill" style="color:#28a745 !important">‚Üó ${s.elevationGain}m</span>
                    <span class="route-stat-pill" style="color:#dc3545 !important">‚Üò ${s.elevationLoss}m</span>
                    ${timeStr}
                </div>
            </div>
            <button onclick="window.gpxMaps['${this.mapId}'].downloadGPX(${id})" title="Download GPX" style="background:transparent;color:#007bff;border:1px solid #cce5ff;border-radius:4px;padding:2px 6px;cursor:pointer;font-size:1.1rem;">üì•</button>
          `;
          list.appendChild(div);
        });
      }

      highlightRoute(id, active) {
          const layer = this.routeLayers.get(id);
          if (layer && this.map.hasLayer(layer)) {
              layer.setStyle({ weight: active ? (this.config.style.weight + 3) : this.config.style.weight, opacity: active ? 1.0 : this.config.style.opacity });
              if (active) layer.bringToFront();
          }
      }

      toggleRoute(id) {
        const l = this.routeLayers.get(id); const m = this.markerLayers.get(id);
        if(!l) return; 
        if(this.map.hasLayer(l)) { this.map.removeLayer(l); if(m) this.map.removeLayer(m); } 
        else { this.map.addLayer(l); if(m) this.map.addLayer(m); }
        this.updateAllComponents();
      }
      
      showAllRoutes() { this.batchUpdateRoutes(true); }
      hideAllRoutes() { this.batchUpdateRoutes(false); }
      batchUpdateRoutes(show) {
          this.routeLayers.forEach((l, id) => { 
              const m = this.markerLayers.get(id);
              if(show && !this.map.hasLayer(l)) { this.map.addLayer(l); if(m) this.map.addLayer(m); }
              if(!show && this.map.hasLayer(l)) { this.map.removeLayer(l); if(m) this.map.removeLayer(m); }
          });
          this.updateAllComponents();
          if(show) this.fitToRoutes();
      }

      updateAllComponents() { this.createRouteSelector(); if(this.config.showStats) this.calculateAndShowTotalStats(); this._drawElevationProfile(); }
      
      fitToRoutes() {
        const layers = []; this.routeLayers.forEach(l => { if(this.map.hasLayer(l)) layers.push(l); });
        if(layers.length) this.map.flyToBounds(L.featureGroup(layers).getBounds(), {padding:[20,20], duration: 1.5});
      }

      calculateAndShowTotalStats() {
        const el = document.getElementById(this.statsId);
        if(!el) return;
        let d=0, eg=0, eloss=0, c=0, time=0;
        this.routeLayers.forEach((l, id) => {
           if(this.map.hasLayer(l)) { c++; const s = this.routeStats.get(id); d+=s.distance; eg+=s.elevationGain; eloss+=s.elevationLoss; time+=s.duration; }
        });
        el.querySelector('[data-stat="distance"]').textContent = d.toFixed(2);
        
        // FIXED LAYOUT: Red arrow on new line
        el.querySelector('[data-stat="elevation"]').innerHTML = `
          <div style="display:flex; flex-direction:column; justify-content:center; align-items:center; line-height:1.2;">
             <span style="color:#28a745 !important">‚Üó ${eg}m</span>
             <span style="color:#dc3545 !important">‚Üò ${eloss}m</span>
          </div>
        `;
        
        el.querySelector('[data-stat="time"]').textContent = this.formatTime(time);
        el.querySelector('[data-stat="routeCount"]').textContent = c;
        el.style.display = c > 0 ? 'block' : 'none';
      }

      getFileName(f) { return f.split('/').pop().replace('.gpx', '').replace(/[-_]/g, ' '); }
      
      downloadGPX(id) {
         const path = this.routeData.get(id)?.originalFile; if(!path) return;
         fetch(path).then(r=>r.text()).then(t=> {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([t],{type:'application/gpx+xml'}));
            a.download = path.split('/').pop();
            a.click();
         });
      }
      
      setupResizeHandling() { 
          const el = document.getElementById(this.mapId);
          const redraw = () => { if(this.map) { this.map.invalidateSize(); } this._drawElevationProfile(); };
          window.addEventListener('resize', redraw);
          if(el && typeof ResizeObserver !== 'undefined') new ResizeObserver(redraw).observe(el);
          setTimeout(redraw, 500); 
      }
      fitToVisibleRoutes() { this.fitToRoutes(); }
    }

    /* --- BOOTSTRAP --- */
    const gpxFilesRaw = [];
    {{- range $gpxFiles -}}gpxFilesRaw.push("{{ . }}");{{- end -}}

    // INJECTING GLOBAL CONFIGURATION INTO JS
    const config = {
        showStats: {{ $showStats }},
        showMarkers: {{ $showMarkers }},
        markerEndColor: '{{ $markerEndColor }}',
        ele: { active: {{ $showElevation }}, color: '{{ $eleColor }}' },
        defaultLayer: '{{ $defaultLayer }}',
        tiles: {
            osm: { url: '{{ $osmUrl }}', attr: '{{ $osmAttr | safeJS }}' },
            topo: { url: '{{ $topoUrl }}', attr: '{{ $topoAttr | safeJS }}' },
            sat: { url: '{{ $satUrl }}', attr: '{{ $satAttr | safeJS }}' }
        },
        view: { lat: {{ $startLat }}, lon: {{ $startLon }}, zoom: {{ $startZoom }} },
        style: { weight: {{ $lineWeight }}, opacity: {{ $lineOpacity }} },
        colors: {{ $colorList | jsonify }}
    };

    const handler = new GPXMapHandler('{{ $id }}', '{{ $id }}-stats', gpxFilesRaw, config);
    if(!window.gpxMaps) window.gpxMaps = {};
    window.gpxMaps['{{ $id }}'] = handler;

    const initMapOnView = () => {
        const target = document.getElementById('{{ $id }}');
        if (!('IntersectionObserver' in window)) { handler.init(); return; }
        const observer = new IntersectionObserver((entries, obs) => {
            entries.forEach(entry => { if (entry.isIntersecting) { handler.init(); obs.unobserve(entry.target); } });
        }, { rootMargin: "200px" });
        if (target) observer.observe(target);
    };
    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', initMapOnView); } else { initMapOnView(); }
  })();
  </script>
{{- end -}}